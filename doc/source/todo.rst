TODO
====

* Install packages

  * Finish stream compression implementation
  * Extract SQLite DB to temporary location
  * Add a ``SourcePackageReader`` which can read from (optionally compressed) memory

* Implement various compressors/decompressors. The API allows for no compression, LZ4, ZIP, LZHAM and LZMA currently, of which only ZIP is implemented so far.

* The installation should be staged in the target directory (``TargetDirectory/.kyla-stage-UUID``)

* Deployment database

  * Write deployment database during installation. This should go into a per-user location, for example, ``.kyla/<persistent-id>/<product-id>.db``. It must store at least:

    * All installed features
    * Properties set during the installation
    * The installation database
    * All installed files
    * All installed content objects

  * Repair an installation based on the features stored in the deployment database and the installation database. This should check all files, find modified files and extract the corresponding content objects from the source packages again.

  * Modify features by adding/removing features.
  * Complete uninstall.

* The XML file should be validated against the XML schema. This requires the use of a validating XML parser like Xerces.
* ``libcurl`` based ``SourcePackageReader`` if the source package location is an URL.
* Add a simple Qt5 based example UI.
* Compute the feature disk-size (already returned by the API, but not implemented yet.)
* Add support for patches and updates (see below for details).

Patches and updates
-------------------

**kyla** should support patches and updates. Updates are the general case, where a product with a version X is updated to version Y by providing a full installation package for version Y. In this case, the installer has to compute a diff of version Y to version X, remove all files which are not in version Y and add the new files. This will be always possible, as in the basic implementation, it can remove all of X and install Y from scratch as all data required for Y is present.

Patches are updates which have a reduced installation package. Instead of providing all files for version Y, they contain only the changed content objects for version Y. A patch can be generated by computing the difference between two installation packages -- all content objects present in Y, but not in X, have to be included in the patch, plus a list of all files that have to be deleted. Moved files could be also detected here as an optimization.

With an update, it is possible to update every version X<Y to Y, while a patch has to be created for a set of versions. For instance, it should be possible to diff version 2.1.0 to the 2.0.0 and 2.0.1 installers and create an unified patch (2.0.x->2.1.0), which won't be able to update from 1.x.y though.
